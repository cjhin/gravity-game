Ashley Taylor & Charles Jhin
CSE 20211.01
Lab10 Report

        Lab 10 contained one program final.c

        NOTE: Can be compiled with the makefile, command: make

        final.c was originally intended to be a simple planetary gravity simulator.  In our design document we outlined a program where "the user can place ships on the screen and the ships will react according to the gravitational pull of the planets".  To our pleasant surprise the end product ended up not only fulfilling this goal but going much further.
	There are two modes, "sandbox" and "arcade".  In "sandbox" mode, the user can add planets or ships (up to ten of each) and create/test out different situations.  The user can also reset the ships or planets so as to place new ones.  Everything is done by clicking with the mouse, and the user can toggle between the different placement/reset options with a toolbar of buttons along the bottom of the screen.  This mode is close to what we had originally intended in the design document.
	In "arcade" mode, the user is presented with 10 "levels".  Each "level" has a different configuration of non-adjustable planets.  The goal is to keep a ship on the screen for the longest amount of time possible (up to 200 seconds before it advances to the next level) without it colliding with a planet.  The user is given a score for every level based on how long the ship stayed alive, with a cumulative score presented at the end of the 10 "levels".
	For both modes, "q" can be used to quit at any time.  As an entertaining aside, Ashley's high score was 754, Chas' was 972.  Can you beat it?

	From a programmer's perspective, there are a few key points that allow the program to work as well as it does.  The first is the struct Ball.  This struct is used to build both the planets and the ships, and with it's properties of mass, radius, position and velocity, allows the planets and ships to interact with each other according to the laws of gravity.  The second is the gfx.h library provided for use in earlier fund comp projects.  The third is David Lopes' alphanum.h library (used with permission), which allows for not only the drawing of boxes and other shapes, but more importantly the drawing of strings (and by extension int/float/doubles) to the screen, which is key to any interactive graphical program.
	main() creates the window and calls readLevels() which reads the levels in from levels.txt for use in arcade mode, and intro() which is in charge of setting up the intro screen.  intro() calls seedIntro() to create the animation of the two ships and two planets, has a switch to check for mouse clicks on the various main screen buttons, and calls introScreen(ran), which takes care of drawing the various buttons and text.  If either the "sandbox" or "arcade" buttons are pressed, then sandbox() or arcade() is called, respectively.
	sandbox() calls drawCreativeButtons() to draw the toolbar at the bottom, has a switch to check for button clicks or ship placements, and calls animate() to animate the ships and planets that have been placed.  
	arcade() is structured similarly to creative(), with a few additions.  For one it calls arcadeInstructionScreen(), levelScreen(level), and drawScore(level), three functions that deal with text in the arcade game.  seedPlanets(level) is also called, which populates the planets[] for each different level.  Finally both the score and total score are kept track of.
	click(double x, double y, int clickNum), is an important function that deals with the placement of ships.  Given an x and y, it will either place a ship if clickNum==1 (first click), or it will set the ships initial velocity (second click), and set it in motion.  It does this with the help of the global variable "s", which tells click() which index in ships[] to manipulate.  It also includes things such as a velocity cap and an error message when more than 10 ships are placed.
	There are three methods important for the actual interaction of the ships and planets and the resulting animations.  These are animate(), updateShipPosition(), and checkCollision().  When animate() is called it first draws all the planets currently in planets[]with drawBall().  It then runs a for loop through all the ships in ships[].  If a ship exists, it will call updateShipPosition() and then checkCollision() before finally drawing the ship with drawBall().  If a ship exists but hasn't had its initial velocity set yet, then it will be drawn, but the other functions will not be called.  If the ship is dead, then the explosion animation will be triggered; the animation steps are kept track of by manipulating the mass into the negative values(allowing it to exist without moving).
	updateShipPosition() is the key physics component of the program, doing the actual calculations of Newton's laws of gravity.  It calculates the force exerted on a ship by every planet on the screen.  It does this by calculating the distance and then derives the gravitational force using the masses of the objects, splitting this force into x and y components, and then finally applying these forces to the position and velocity of the ship.
	checkCollision() checks to see if a ship has collided with any planet, and if so sets the mass to negative to alert animate() to start the explosion animation.  Because the ships sometimes move so fast that the path goes through a planet, but both the current and next position are "safe", there are some calculations involved to check the path as well.  In other words, this addresses a glitch where a ship could pass through a planet unharmed if going fast enough.

	The program addresses many of the possible bugs and glitches that came up during our testing of the program.  Many of our issues came with the actual physics of the program.  Although we apply Newton's laws of gravity, specifically his formula F(gravity)=G*m1*m2/d^2, under real (well at least current day) conditions, a spaceship is not almost equivalent in size to a planet.  Or another way to look at is that a planet could not be as massive (dense) as we made them in the program without literally imploding and creating a black hole.  So although it is a planetary physics simulator, we took some liberties with some of the circumstances (in other words this couldn't and shouldn't be used to model interactions in real life, but it creates some quite interesting and entertaining situations).
	However, these liberties we took caused some interesting issues with the gravity interactions.  One example is when a ship approached a planet and came with in a few units of distance it would suddenly be "catapulted" through the planet and out to a galaxy far far away.  In real life, if anything were to come that close to the center of a planet, it would be inside the planet, and therefore gravity would be pretty irrelevant.  However, because our ships can approach very close to the center of a planet (due to the extremely high density), the gravitational forces can reach extreme levels.  Thus, the acceleration can reach a large magnitude and the ship is "catapulted".  Additionally, because animate() can't calculate continuously but instead samples at an arbitrary time interval, by the time the ship is on the other side of the planet, it is so far away that the planet can't pull it back at an equal magnitude.  In order to fix this, we changed it so that within distance of 5 gravity no longer applies.  This sometimes causes occasional quirks where a ship will "dodge" a planet, as the force suddenly no longer applies, but for the most part it works smoothly.  We also introduced a velocity cap to limit "catapults".  
	Another issue dealt with collisions.  Because the ships sometimes move so fast that the path goes through a planet, but both the current and next position are "safe", there was a glitch where a ship could pass through a planet unharmed if going fast enough.  We addressed this by not only checking the current position, but also checking for collision halfway between its current and the future position.  This combined with the velocity cap more or less fixes the problem.  
